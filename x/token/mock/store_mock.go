// Code generated by MockGen. DO NOT EDIT.
// Source: go/pkg/mod/github.com/cosmos/cosmos-sdk@v0.37.0/store/types/store.go

// Package types is a generated GoMock package.
package types

import (
	types "github.com/cosmos/cosmos-sdk/store/types"
	gomock "github.com/golang/mock/gomock"
	types0 "github.com/tendermint/tendermint/abci/types"
	tm_db "github.com/tendermint/tm-db"
	io "io"
	reflect "reflect"
)

// MockStore is a mock of Store interface
type MockStore struct {
	ctrl     *gomock.Controller
	recorder *MockStoreMockRecorder
}

// MockStoreMockRecorder is the mock recorder for MockStore
type MockStoreMockRecorder struct {
	mock *MockStore
}

// NewMockStore creates a new mock instance
func NewMockStore(ctrl *gomock.Controller) *MockStore {
	mock := &MockStore{ctrl: ctrl}
	mock.recorder = &MockStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockStore) EXPECT() *MockStoreMockRecorder {
	return m.recorder
}

// GetStoreType mocks base method
func (m *MockStore) GetStoreType() types.StoreType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStoreType")
	ret0, _ := ret[0].(types.StoreType)
	return ret0
}

// GetStoreType indicates an expected call of GetStoreType
func (mr *MockStoreMockRecorder) GetStoreType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStoreType", reflect.TypeOf((*MockStore)(nil).GetStoreType))
}

// CacheWrap mocks base method
func (m *MockStore) CacheWrap() types.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrap")
	ret0, _ := ret[0].(types.CacheWrap)
	return ret0
}

// CacheWrap indicates an expected call of CacheWrap
func (mr *MockStoreMockRecorder) CacheWrap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrap", reflect.TypeOf((*MockStore)(nil).CacheWrap))
}

// CacheWrapWithTrace mocks base method
func (m *MockStore) CacheWrapWithTrace(w io.Writer, tc types.TraceContext) types.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrapWithTrace", w, tc)
	ret0, _ := ret[0].(types.CacheWrap)
	return ret0
}

// CacheWrapWithTrace indicates an expected call of CacheWrapWithTrace
func (mr *MockStoreMockRecorder) CacheWrapWithTrace(w, tc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrapWithTrace", reflect.TypeOf((*MockStore)(nil).CacheWrapWithTrace), w, tc)
}

// MockCommitter is a mock of Committer interface
type MockCommitter struct {
	ctrl     *gomock.Controller
	recorder *MockCommitterMockRecorder
}

// MockCommitterMockRecorder is the mock recorder for MockCommitter
type MockCommitterMockRecorder struct {
	mock *MockCommitter
}

// NewMockCommitter creates a new mock instance
func NewMockCommitter(ctrl *gomock.Controller) *MockCommitter {
	mock := &MockCommitter{ctrl: ctrl}
	mock.recorder = &MockCommitterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCommitter) EXPECT() *MockCommitterMockRecorder {
	return m.recorder
}

// Commit mocks base method
func (m *MockCommitter) Commit() types.CommitID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(types.CommitID)
	return ret0
}

// Commit indicates an expected call of Commit
func (mr *MockCommitterMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockCommitter)(nil).Commit))
}

// LastCommitID mocks base method
func (m *MockCommitter) LastCommitID() types.CommitID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LastCommitID")
	ret0, _ := ret[0].(types.CommitID)
	return ret0
}

// LastCommitID indicates an expected call of LastCommitID
func (mr *MockCommitterMockRecorder) LastCommitID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastCommitID", reflect.TypeOf((*MockCommitter)(nil).LastCommitID))
}

// SetPruning mocks base method
func (m *MockCommitter) SetPruning(arg0 types.PruningOptions) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetPruning", arg0)
}

// SetPruning indicates an expected call of SetPruning
func (mr *MockCommitterMockRecorder) SetPruning(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetPruning", reflect.TypeOf((*MockCommitter)(nil).SetPruning), arg0)
}

// MockCommitStore is a mock of CommitStore interface
type MockCommitStore struct {
	ctrl     *gomock.Controller
	recorder *MockCommitStoreMockRecorder
}

// MockCommitStoreMockRecorder is the mock recorder for MockCommitStore
type MockCommitStoreMockRecorder struct {
	mock *MockCommitStore
}

// NewMockCommitStore creates a new mock instance
func NewMockCommitStore(ctrl *gomock.Controller) *MockCommitStore {
	mock := &MockCommitStore{ctrl: ctrl}
	mock.recorder = &MockCommitStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCommitStore) EXPECT() *MockCommitStoreMockRecorder {
	return m.recorder
}

// Commit mocks base method
func (m *MockCommitStore) Commit() types.CommitID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(types.CommitID)
	return ret0
}

// Commit indicates an expected call of Commit
func (mr *MockCommitStoreMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockCommitStore)(nil).Commit))
}

// LastCommitID mocks base method
func (m *MockCommitStore) LastCommitID() types.CommitID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LastCommitID")
	ret0, _ := ret[0].(types.CommitID)
	return ret0
}

// LastCommitID indicates an expected call of LastCommitID
func (mr *MockCommitStoreMockRecorder) LastCommitID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastCommitID", reflect.TypeOf((*MockCommitStore)(nil).LastCommitID))
}

// SetPruning mocks base method
func (m *MockCommitStore) SetPruning(arg0 types.PruningOptions) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetPruning", arg0)
}

// SetPruning indicates an expected call of SetPruning
func (mr *MockCommitStoreMockRecorder) SetPruning(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetPruning", reflect.TypeOf((*MockCommitStore)(nil).SetPruning), arg0)
}

// GetStoreType mocks base method
func (m *MockCommitStore) GetStoreType() types.StoreType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStoreType")
	ret0, _ := ret[0].(types.StoreType)
	return ret0
}

// GetStoreType indicates an expected call of GetStoreType
func (mr *MockCommitStoreMockRecorder) GetStoreType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStoreType", reflect.TypeOf((*MockCommitStore)(nil).GetStoreType))
}

// CacheWrap mocks base method
func (m *MockCommitStore) CacheWrap() types.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrap")
	ret0, _ := ret[0].(types.CacheWrap)
	return ret0
}

// CacheWrap indicates an expected call of CacheWrap
func (mr *MockCommitStoreMockRecorder) CacheWrap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrap", reflect.TypeOf((*MockCommitStore)(nil).CacheWrap))
}

// CacheWrapWithTrace mocks base method
func (m *MockCommitStore) CacheWrapWithTrace(w io.Writer, tc types.TraceContext) types.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrapWithTrace", w, tc)
	ret0, _ := ret[0].(types.CacheWrap)
	return ret0
}

// CacheWrapWithTrace indicates an expected call of CacheWrapWithTrace
func (mr *MockCommitStoreMockRecorder) CacheWrapWithTrace(w, tc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrapWithTrace", reflect.TypeOf((*MockCommitStore)(nil).CacheWrapWithTrace), w, tc)
}

// MockQueryable is a mock of Queryable interface
type MockQueryable struct {
	ctrl     *gomock.Controller
	recorder *MockQueryableMockRecorder
}

// MockQueryableMockRecorder is the mock recorder for MockQueryable
type MockQueryableMockRecorder struct {
	mock *MockQueryable
}

// NewMockQueryable creates a new mock instance
func NewMockQueryable(ctrl *gomock.Controller) *MockQueryable {
	mock := &MockQueryable{ctrl: ctrl}
	mock.recorder = &MockQueryableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockQueryable) EXPECT() *MockQueryableMockRecorder {
	return m.recorder
}

// Query mocks base method
func (m *MockQueryable) Query(arg0 types0.RequestQuery) types0.ResponseQuery {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Query", arg0)
	ret0, _ := ret[0].(types0.ResponseQuery)
	return ret0
}

// Query indicates an expected call of Query
func (mr *MockQueryableMockRecorder) Query(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockQueryable)(nil).Query), arg0)
}

// MockMultiStore is a mock of MultiStore interface
type MockMultiStore struct {
	ctrl     *gomock.Controller
	recorder *MockMultiStoreMockRecorder
}

// MockMultiStoreMockRecorder is the mock recorder for MockMultiStore
type MockMultiStoreMockRecorder struct {
	mock *MockMultiStore
}

// NewMockMultiStore creates a new mock instance
func NewMockMultiStore(ctrl *gomock.Controller) *MockMultiStore {
	mock := &MockMultiStore{ctrl: ctrl}
	mock.recorder = &MockMultiStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockMultiStore) EXPECT() *MockMultiStoreMockRecorder {
	return m.recorder
}

// GetStoreType mocks base method
func (m *MockMultiStore) GetStoreType() types.StoreType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStoreType")
	ret0, _ := ret[0].(types.StoreType)
	return ret0
}

// GetStoreType indicates an expected call of GetStoreType
func (mr *MockMultiStoreMockRecorder) GetStoreType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStoreType", reflect.TypeOf((*MockMultiStore)(nil).GetStoreType))
}

// CacheWrap mocks base method
func (m *MockMultiStore) CacheWrap() types.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrap")
	ret0, _ := ret[0].(types.CacheWrap)
	return ret0
}

// CacheWrap indicates an expected call of CacheWrap
func (mr *MockMultiStoreMockRecorder) CacheWrap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrap", reflect.TypeOf((*MockMultiStore)(nil).CacheWrap))
}

// CacheWrapWithTrace mocks base method
func (m *MockMultiStore) CacheWrapWithTrace(w io.Writer, tc types.TraceContext) types.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrapWithTrace", w, tc)
	ret0, _ := ret[0].(types.CacheWrap)
	return ret0
}

// CacheWrapWithTrace indicates an expected call of CacheWrapWithTrace
func (mr *MockMultiStoreMockRecorder) CacheWrapWithTrace(w, tc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrapWithTrace", reflect.TypeOf((*MockMultiStore)(nil).CacheWrapWithTrace), w, tc)
}

// CacheMultiStore mocks base method
func (m *MockMultiStore) CacheMultiStore() types.CacheMultiStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheMultiStore")
	ret0, _ := ret[0].(types.CacheMultiStore)
	return ret0
}

// CacheMultiStore indicates an expected call of CacheMultiStore
func (mr *MockMultiStoreMockRecorder) CacheMultiStore() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheMultiStore", reflect.TypeOf((*MockMultiStore)(nil).CacheMultiStore))
}

// CacheMultiStoreWithVersion mocks base method
func (m *MockMultiStore) CacheMultiStoreWithVersion(version int64) (types.CacheMultiStore, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheMultiStoreWithVersion", version)
	ret0, _ := ret[0].(types.CacheMultiStore)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CacheMultiStoreWithVersion indicates an expected call of CacheMultiStoreWithVersion
func (mr *MockMultiStoreMockRecorder) CacheMultiStoreWithVersion(version interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheMultiStoreWithVersion", reflect.TypeOf((*MockMultiStore)(nil).CacheMultiStoreWithVersion), version)
}

// GetStore mocks base method
func (m *MockMultiStore) GetStore(arg0 types.StoreKey) types.Store {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStore", arg0)
	ret0, _ := ret[0].(types.Store)
	return ret0
}

// GetStore indicates an expected call of GetStore
func (mr *MockMultiStoreMockRecorder) GetStore(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStore", reflect.TypeOf((*MockMultiStore)(nil).GetStore), arg0)
}

// GetKVStore mocks base method
func (m *MockMultiStore) GetKVStore(arg0 types.StoreKey) types.KVStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetKVStore", arg0)
	ret0, _ := ret[0].(types.KVStore)
	return ret0
}

// GetKVStore indicates an expected call of GetKVStore
func (mr *MockMultiStoreMockRecorder) GetKVStore(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetKVStore", reflect.TypeOf((*MockMultiStore)(nil).GetKVStore), arg0)
}

// TracingEnabled mocks base method
func (m *MockMultiStore) TracingEnabled() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TracingEnabled")
	ret0, _ := ret[0].(bool)
	return ret0
}

// TracingEnabled indicates an expected call of TracingEnabled
func (mr *MockMultiStoreMockRecorder) TracingEnabled() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TracingEnabled", reflect.TypeOf((*MockMultiStore)(nil).TracingEnabled))
}

// SetTracer mocks base method
func (m *MockMultiStore) SetTracer(w io.Writer) types.MultiStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetTracer", w)
	ret0, _ := ret[0].(types.MultiStore)
	return ret0
}

// SetTracer indicates an expected call of SetTracer
func (mr *MockMultiStoreMockRecorder) SetTracer(w interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetTracer", reflect.TypeOf((*MockMultiStore)(nil).SetTracer), w)
}

// SetTracingContext mocks base method
func (m *MockMultiStore) SetTracingContext(arg0 types.TraceContext) types.MultiStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetTracingContext", arg0)
	ret0, _ := ret[0].(types.MultiStore)
	return ret0
}

// SetTracingContext indicates an expected call of SetTracingContext
func (mr *MockMultiStoreMockRecorder) SetTracingContext(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetTracingContext", reflect.TypeOf((*MockMultiStore)(nil).SetTracingContext), arg0)
}

// MockCacheMultiStore is a mock of CacheMultiStore interface
type MockCacheMultiStore struct {
	ctrl     *gomock.Controller
	recorder *MockCacheMultiStoreMockRecorder
}

// MockCacheMultiStoreMockRecorder is the mock recorder for MockCacheMultiStore
type MockCacheMultiStoreMockRecorder struct {
	mock *MockCacheMultiStore
}

// NewMockCacheMultiStore creates a new mock instance
func NewMockCacheMultiStore(ctrl *gomock.Controller) *MockCacheMultiStore {
	mock := &MockCacheMultiStore{ctrl: ctrl}
	mock.recorder = &MockCacheMultiStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCacheMultiStore) EXPECT() *MockCacheMultiStoreMockRecorder {
	return m.recorder
}

// GetStoreType mocks base method
func (m *MockCacheMultiStore) GetStoreType() types.StoreType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStoreType")
	ret0, _ := ret[0].(types.StoreType)
	return ret0
}

// GetStoreType indicates an expected call of GetStoreType
func (mr *MockCacheMultiStoreMockRecorder) GetStoreType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStoreType", reflect.TypeOf((*MockCacheMultiStore)(nil).GetStoreType))
}

// CacheWrap mocks base method
func (m *MockCacheMultiStore) CacheWrap() types.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrap")
	ret0, _ := ret[0].(types.CacheWrap)
	return ret0
}

// CacheWrap indicates an expected call of CacheWrap
func (mr *MockCacheMultiStoreMockRecorder) CacheWrap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrap", reflect.TypeOf((*MockCacheMultiStore)(nil).CacheWrap))
}

// CacheWrapWithTrace mocks base method
func (m *MockCacheMultiStore) CacheWrapWithTrace(w io.Writer, tc types.TraceContext) types.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrapWithTrace", w, tc)
	ret0, _ := ret[0].(types.CacheWrap)
	return ret0
}

// CacheWrapWithTrace indicates an expected call of CacheWrapWithTrace
func (mr *MockCacheMultiStoreMockRecorder) CacheWrapWithTrace(w, tc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrapWithTrace", reflect.TypeOf((*MockCacheMultiStore)(nil).CacheWrapWithTrace), w, tc)
}

// CacheMultiStore mocks base method
func (m *MockCacheMultiStore) CacheMultiStore() types.CacheMultiStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheMultiStore")
	ret0, _ := ret[0].(types.CacheMultiStore)
	return ret0
}

// CacheMultiStore indicates an expected call of CacheMultiStore
func (mr *MockCacheMultiStoreMockRecorder) CacheMultiStore() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheMultiStore", reflect.TypeOf((*MockCacheMultiStore)(nil).CacheMultiStore))
}

// CacheMultiStoreWithVersion mocks base method
func (m *MockCacheMultiStore) CacheMultiStoreWithVersion(version int64) (types.CacheMultiStore, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheMultiStoreWithVersion", version)
	ret0, _ := ret[0].(types.CacheMultiStore)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CacheMultiStoreWithVersion indicates an expected call of CacheMultiStoreWithVersion
func (mr *MockCacheMultiStoreMockRecorder) CacheMultiStoreWithVersion(version interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheMultiStoreWithVersion", reflect.TypeOf((*MockCacheMultiStore)(nil).CacheMultiStoreWithVersion), version)
}

// GetStore mocks base method
func (m *MockCacheMultiStore) GetStore(arg0 types.StoreKey) types.Store {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStore", arg0)
	ret0, _ := ret[0].(types.Store)
	return ret0
}

// GetStore indicates an expected call of GetStore
func (mr *MockCacheMultiStoreMockRecorder) GetStore(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStore", reflect.TypeOf((*MockCacheMultiStore)(nil).GetStore), arg0)
}

// GetKVStore mocks base method
func (m *MockCacheMultiStore) GetKVStore(arg0 types.StoreKey) types.KVStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetKVStore", arg0)
	ret0, _ := ret[0].(types.KVStore)
	return ret0
}

// GetKVStore indicates an expected call of GetKVStore
func (mr *MockCacheMultiStoreMockRecorder) GetKVStore(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetKVStore", reflect.TypeOf((*MockCacheMultiStore)(nil).GetKVStore), arg0)
}

// TracingEnabled mocks base method
func (m *MockCacheMultiStore) TracingEnabled() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TracingEnabled")
	ret0, _ := ret[0].(bool)
	return ret0
}

// TracingEnabled indicates an expected call of TracingEnabled
func (mr *MockCacheMultiStoreMockRecorder) TracingEnabled() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TracingEnabled", reflect.TypeOf((*MockCacheMultiStore)(nil).TracingEnabled))
}

// SetTracer mocks base method
func (m *MockCacheMultiStore) SetTracer(w io.Writer) types.MultiStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetTracer", w)
	ret0, _ := ret[0].(types.MultiStore)
	return ret0
}

// SetTracer indicates an expected call of SetTracer
func (mr *MockCacheMultiStoreMockRecorder) SetTracer(w interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetTracer", reflect.TypeOf((*MockCacheMultiStore)(nil).SetTracer), w)
}

// SetTracingContext mocks base method
func (m *MockCacheMultiStore) SetTracingContext(arg0 types.TraceContext) types.MultiStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetTracingContext", arg0)
	ret0, _ := ret[0].(types.MultiStore)
	return ret0
}

// SetTracingContext indicates an expected call of SetTracingContext
func (mr *MockCacheMultiStoreMockRecorder) SetTracingContext(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetTracingContext", reflect.TypeOf((*MockCacheMultiStore)(nil).SetTracingContext), arg0)
}

// Write mocks base method
func (m *MockCacheMultiStore) Write() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Write")
}

// Write indicates an expected call of Write
func (mr *MockCacheMultiStoreMockRecorder) Write() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockCacheMultiStore)(nil).Write))
}

// MockCommitMultiStore is a mock of CommitMultiStore interface
type MockCommitMultiStore struct {
	ctrl     *gomock.Controller
	recorder *MockCommitMultiStoreMockRecorder
}

// MockCommitMultiStoreMockRecorder is the mock recorder for MockCommitMultiStore
type MockCommitMultiStoreMockRecorder struct {
	mock *MockCommitMultiStore
}

// NewMockCommitMultiStore creates a new mock instance
func NewMockCommitMultiStore(ctrl *gomock.Controller) *MockCommitMultiStore {
	mock := &MockCommitMultiStore{ctrl: ctrl}
	mock.recorder = &MockCommitMultiStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCommitMultiStore) EXPECT() *MockCommitMultiStoreMockRecorder {
	return m.recorder
}

// Commit mocks base method
func (m *MockCommitMultiStore) Commit() types.CommitID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(types.CommitID)
	return ret0
}

// Commit indicates an expected call of Commit
func (mr *MockCommitMultiStoreMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockCommitMultiStore)(nil).Commit))
}

// LastCommitID mocks base method
func (m *MockCommitMultiStore) LastCommitID() types.CommitID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LastCommitID")
	ret0, _ := ret[0].(types.CommitID)
	return ret0
}

// LastCommitID indicates an expected call of LastCommitID
func (mr *MockCommitMultiStoreMockRecorder) LastCommitID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastCommitID", reflect.TypeOf((*MockCommitMultiStore)(nil).LastCommitID))
}

// SetPruning mocks base method
func (m *MockCommitMultiStore) SetPruning(arg0 types.PruningOptions) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetPruning", arg0)
}

// SetPruning indicates an expected call of SetPruning
func (mr *MockCommitMultiStoreMockRecorder) SetPruning(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetPruning", reflect.TypeOf((*MockCommitMultiStore)(nil).SetPruning), arg0)
}

// GetStoreType mocks base method
func (m *MockCommitMultiStore) GetStoreType() types.StoreType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStoreType")
	ret0, _ := ret[0].(types.StoreType)
	return ret0
}

// GetStoreType indicates an expected call of GetStoreType
func (mr *MockCommitMultiStoreMockRecorder) GetStoreType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStoreType", reflect.TypeOf((*MockCommitMultiStore)(nil).GetStoreType))
}

// CacheWrap mocks base method
func (m *MockCommitMultiStore) CacheWrap() types.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrap")
	ret0, _ := ret[0].(types.CacheWrap)
	return ret0
}

// CacheWrap indicates an expected call of CacheWrap
func (mr *MockCommitMultiStoreMockRecorder) CacheWrap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrap", reflect.TypeOf((*MockCommitMultiStore)(nil).CacheWrap))
}

// CacheWrapWithTrace mocks base method
func (m *MockCommitMultiStore) CacheWrapWithTrace(w io.Writer, tc types.TraceContext) types.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrapWithTrace", w, tc)
	ret0, _ := ret[0].(types.CacheWrap)
	return ret0
}

// CacheWrapWithTrace indicates an expected call of CacheWrapWithTrace
func (mr *MockCommitMultiStoreMockRecorder) CacheWrapWithTrace(w, tc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrapWithTrace", reflect.TypeOf((*MockCommitMultiStore)(nil).CacheWrapWithTrace), w, tc)
}

// CacheMultiStore mocks base method
func (m *MockCommitMultiStore) CacheMultiStore() types.CacheMultiStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheMultiStore")
	ret0, _ := ret[0].(types.CacheMultiStore)
	return ret0
}

// CacheMultiStore indicates an expected call of CacheMultiStore
func (mr *MockCommitMultiStoreMockRecorder) CacheMultiStore() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheMultiStore", reflect.TypeOf((*MockCommitMultiStore)(nil).CacheMultiStore))
}

// CacheMultiStoreWithVersion mocks base method
func (m *MockCommitMultiStore) CacheMultiStoreWithVersion(version int64) (types.CacheMultiStore, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheMultiStoreWithVersion", version)
	ret0, _ := ret[0].(types.CacheMultiStore)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CacheMultiStoreWithVersion indicates an expected call of CacheMultiStoreWithVersion
func (mr *MockCommitMultiStoreMockRecorder) CacheMultiStoreWithVersion(version interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheMultiStoreWithVersion", reflect.TypeOf((*MockCommitMultiStore)(nil).CacheMultiStoreWithVersion), version)
}

// GetStore mocks base method
func (m *MockCommitMultiStore) GetStore(arg0 types.StoreKey) types.Store {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStore", arg0)
	ret0, _ := ret[0].(types.Store)
	return ret0
}

// GetStore indicates an expected call of GetStore
func (mr *MockCommitMultiStoreMockRecorder) GetStore(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStore", reflect.TypeOf((*MockCommitMultiStore)(nil).GetStore), arg0)
}

// GetKVStore mocks base method
func (m *MockCommitMultiStore) GetKVStore(arg0 types.StoreKey) types.KVStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetKVStore", arg0)
	ret0, _ := ret[0].(types.KVStore)
	return ret0
}

// GetKVStore indicates an expected call of GetKVStore
func (mr *MockCommitMultiStoreMockRecorder) GetKVStore(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetKVStore", reflect.TypeOf((*MockCommitMultiStore)(nil).GetKVStore), arg0)
}

// TracingEnabled mocks base method
func (m *MockCommitMultiStore) TracingEnabled() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TracingEnabled")
	ret0, _ := ret[0].(bool)
	return ret0
}

// TracingEnabled indicates an expected call of TracingEnabled
func (mr *MockCommitMultiStoreMockRecorder) TracingEnabled() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TracingEnabled", reflect.TypeOf((*MockCommitMultiStore)(nil).TracingEnabled))
}

// SetTracer mocks base method
func (m *MockCommitMultiStore) SetTracer(w io.Writer) types.MultiStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetTracer", w)
	ret0, _ := ret[0].(types.MultiStore)
	return ret0
}

// SetTracer indicates an expected call of SetTracer
func (mr *MockCommitMultiStoreMockRecorder) SetTracer(w interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetTracer", reflect.TypeOf((*MockCommitMultiStore)(nil).SetTracer), w)
}

// SetTracingContext mocks base method
func (m *MockCommitMultiStore) SetTracingContext(arg0 types.TraceContext) types.MultiStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetTracingContext", arg0)
	ret0, _ := ret[0].(types.MultiStore)
	return ret0
}

// SetTracingContext indicates an expected call of SetTracingContext
func (mr *MockCommitMultiStoreMockRecorder) SetTracingContext(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetTracingContext", reflect.TypeOf((*MockCommitMultiStore)(nil).SetTracingContext), arg0)
}

// MountStoreWithDB mocks base method
func (m *MockCommitMultiStore) MountStoreWithDB(key types.StoreKey, typ types.StoreType, db tm_db.DB) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "MountStoreWithDB", key, typ, db)
}

// MountStoreWithDB indicates an expected call of MountStoreWithDB
func (mr *MockCommitMultiStoreMockRecorder) MountStoreWithDB(key, typ, db interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MountStoreWithDB", reflect.TypeOf((*MockCommitMultiStore)(nil).MountStoreWithDB), key, typ, db)
}

// GetCommitStore mocks base method
func (m *MockCommitMultiStore) GetCommitStore(key types.StoreKey) types.CommitStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCommitStore", key)
	ret0, _ := ret[0].(types.CommitStore)
	return ret0
}

// GetCommitStore indicates an expected call of GetCommitStore
func (mr *MockCommitMultiStoreMockRecorder) GetCommitStore(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommitStore", reflect.TypeOf((*MockCommitMultiStore)(nil).GetCommitStore), key)
}

// GetCommitKVStore mocks base method
func (m *MockCommitMultiStore) GetCommitKVStore(key types.StoreKey) types.CommitKVStore {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCommitKVStore", key)
	ret0, _ := ret[0].(types.CommitKVStore)
	return ret0
}

// GetCommitKVStore indicates an expected call of GetCommitKVStore
func (mr *MockCommitMultiStoreMockRecorder) GetCommitKVStore(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCommitKVStore", reflect.TypeOf((*MockCommitMultiStore)(nil).GetCommitKVStore), key)
}

// LoadLatestVersion mocks base method
func (m *MockCommitMultiStore) LoadLatestVersion() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoadLatestVersion")
	ret0, _ := ret[0].(error)
	return ret0
}

// LoadLatestVersion indicates an expected call of LoadLatestVersion
func (mr *MockCommitMultiStoreMockRecorder) LoadLatestVersion() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadLatestVersion", reflect.TypeOf((*MockCommitMultiStore)(nil).LoadLatestVersion))
}

// LoadVersion mocks base method
func (m *MockCommitMultiStore) LoadVersion(ver int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LoadVersion", ver)
	ret0, _ := ret[0].(error)
	return ret0
}

// LoadVersion indicates an expected call of LoadVersion
func (mr *MockCommitMultiStoreMockRecorder) LoadVersion(ver interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadVersion", reflect.TypeOf((*MockCommitMultiStore)(nil).LoadVersion), ver)
}

// MockKVStore is a mock of KVStore interface
type MockKVStore struct {
	ctrl     *gomock.Controller
	recorder *MockKVStoreMockRecorder
}

// MockKVStoreMockRecorder is the mock recorder for MockKVStore
type MockKVStoreMockRecorder struct {
	mock *MockKVStore
}

// NewMockKVStore creates a new mock instance
func NewMockKVStore(ctrl *gomock.Controller) *MockKVStore {
	mock := &MockKVStore{ctrl: ctrl}
	mock.recorder = &MockKVStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockKVStore) EXPECT() *MockKVStoreMockRecorder {
	return m.recorder
}

// GetStoreType mocks base method
func (m *MockKVStore) GetStoreType() types.StoreType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStoreType")
	ret0, _ := ret[0].(types.StoreType)
	return ret0
}

// GetStoreType indicates an expected call of GetStoreType
func (mr *MockKVStoreMockRecorder) GetStoreType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStoreType", reflect.TypeOf((*MockKVStore)(nil).GetStoreType))
}

// CacheWrap mocks base method
func (m *MockKVStore) CacheWrap() types.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrap")
	ret0, _ := ret[0].(types.CacheWrap)
	return ret0
}

// CacheWrap indicates an expected call of CacheWrap
func (mr *MockKVStoreMockRecorder) CacheWrap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrap", reflect.TypeOf((*MockKVStore)(nil).CacheWrap))
}

// CacheWrapWithTrace mocks base method
func (m *MockKVStore) CacheWrapWithTrace(w io.Writer, tc types.TraceContext) types.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrapWithTrace", w, tc)
	ret0, _ := ret[0].(types.CacheWrap)
	return ret0
}

// CacheWrapWithTrace indicates an expected call of CacheWrapWithTrace
func (mr *MockKVStoreMockRecorder) CacheWrapWithTrace(w, tc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrapWithTrace", reflect.TypeOf((*MockKVStore)(nil).CacheWrapWithTrace), w, tc)
}

// Get mocks base method
func (m *MockKVStore) Get(key []byte) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", key)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// Get indicates an expected call of Get
func (mr *MockKVStoreMockRecorder) Get(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockKVStore)(nil).Get), key)
}

// Has mocks base method
func (m *MockKVStore) Has(key []byte) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Has", key)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Has indicates an expected call of Has
func (mr *MockKVStoreMockRecorder) Has(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Has", reflect.TypeOf((*MockKVStore)(nil).Has), key)
}

// Set mocks base method
func (m *MockKVStore) Set(key, value []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Set", key, value)
}

// Set indicates an expected call of Set
func (mr *MockKVStoreMockRecorder) Set(key, value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockKVStore)(nil).Set), key, value)
}

// Delete mocks base method
func (m *MockKVStore) Delete(key []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Delete", key)
}

// Delete indicates an expected call of Delete
func (mr *MockKVStoreMockRecorder) Delete(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockKVStore)(nil).Delete), key)
}

// Iterator mocks base method
func (m *MockKVStore) Iterator(start, end []byte) types.Iterator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Iterator", start, end)
	ret0, _ := ret[0].(types.Iterator)
	return ret0
}

// Iterator indicates an expected call of Iterator
func (mr *MockKVStoreMockRecorder) Iterator(start, end interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Iterator", reflect.TypeOf((*MockKVStore)(nil).Iterator), start, end)
}

// ReverseIterator mocks base method
func (m *MockKVStore) ReverseIterator(start, end []byte) types.Iterator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReverseIterator", start, end)
	ret0, _ := ret[0].(types.Iterator)
	return ret0
}

// ReverseIterator indicates an expected call of ReverseIterator
func (mr *MockKVStoreMockRecorder) ReverseIterator(start, end interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReverseIterator", reflect.TypeOf((*MockKVStore)(nil).ReverseIterator), start, end)
}

// MockCacheKVStore is a mock of CacheKVStore interface
type MockCacheKVStore struct {
	ctrl     *gomock.Controller
	recorder *MockCacheKVStoreMockRecorder
}

// MockCacheKVStoreMockRecorder is the mock recorder for MockCacheKVStore
type MockCacheKVStoreMockRecorder struct {
	mock *MockCacheKVStore
}

// NewMockCacheKVStore creates a new mock instance
func NewMockCacheKVStore(ctrl *gomock.Controller) *MockCacheKVStore {
	mock := &MockCacheKVStore{ctrl: ctrl}
	mock.recorder = &MockCacheKVStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCacheKVStore) EXPECT() *MockCacheKVStoreMockRecorder {
	return m.recorder
}

// GetStoreType mocks base method
func (m *MockCacheKVStore) GetStoreType() types.StoreType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStoreType")
	ret0, _ := ret[0].(types.StoreType)
	return ret0
}

// GetStoreType indicates an expected call of GetStoreType
func (mr *MockCacheKVStoreMockRecorder) GetStoreType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStoreType", reflect.TypeOf((*MockCacheKVStore)(nil).GetStoreType))
}

// CacheWrap mocks base method
func (m *MockCacheKVStore) CacheWrap() types.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrap")
	ret0, _ := ret[0].(types.CacheWrap)
	return ret0
}

// CacheWrap indicates an expected call of CacheWrap
func (mr *MockCacheKVStoreMockRecorder) CacheWrap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrap", reflect.TypeOf((*MockCacheKVStore)(nil).CacheWrap))
}

// CacheWrapWithTrace mocks base method
func (m *MockCacheKVStore) CacheWrapWithTrace(w io.Writer, tc types.TraceContext) types.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrapWithTrace", w, tc)
	ret0, _ := ret[0].(types.CacheWrap)
	return ret0
}

// CacheWrapWithTrace indicates an expected call of CacheWrapWithTrace
func (mr *MockCacheKVStoreMockRecorder) CacheWrapWithTrace(w, tc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrapWithTrace", reflect.TypeOf((*MockCacheKVStore)(nil).CacheWrapWithTrace), w, tc)
}

// Get mocks base method
func (m *MockCacheKVStore) Get(key []byte) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", key)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// Get indicates an expected call of Get
func (mr *MockCacheKVStoreMockRecorder) Get(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCacheKVStore)(nil).Get), key)
}

// Has mocks base method
func (m *MockCacheKVStore) Has(key []byte) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Has", key)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Has indicates an expected call of Has
func (mr *MockCacheKVStoreMockRecorder) Has(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Has", reflect.TypeOf((*MockCacheKVStore)(nil).Has), key)
}

// Set mocks base method
func (m *MockCacheKVStore) Set(key, value []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Set", key, value)
}

// Set indicates an expected call of Set
func (mr *MockCacheKVStoreMockRecorder) Set(key, value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockCacheKVStore)(nil).Set), key, value)
}

// Delete mocks base method
func (m *MockCacheKVStore) Delete(key []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Delete", key)
}

// Delete indicates an expected call of Delete
func (mr *MockCacheKVStoreMockRecorder) Delete(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockCacheKVStore)(nil).Delete), key)
}

// Iterator mocks base method
func (m *MockCacheKVStore) Iterator(start, end []byte) types.Iterator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Iterator", start, end)
	ret0, _ := ret[0].(types.Iterator)
	return ret0
}

// Iterator indicates an expected call of Iterator
func (mr *MockCacheKVStoreMockRecorder) Iterator(start, end interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Iterator", reflect.TypeOf((*MockCacheKVStore)(nil).Iterator), start, end)
}

// ReverseIterator mocks base method
func (m *MockCacheKVStore) ReverseIterator(start, end []byte) types.Iterator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReverseIterator", start, end)
	ret0, _ := ret[0].(types.Iterator)
	return ret0
}

// ReverseIterator indicates an expected call of ReverseIterator
func (mr *MockCacheKVStoreMockRecorder) ReverseIterator(start, end interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReverseIterator", reflect.TypeOf((*MockCacheKVStore)(nil).ReverseIterator), start, end)
}

// Write mocks base method
func (m *MockCacheKVStore) Write() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Write")
}

// Write indicates an expected call of Write
func (mr *MockCacheKVStoreMockRecorder) Write() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockCacheKVStore)(nil).Write))
}

// MockCommitKVStore is a mock of CommitKVStore interface
type MockCommitKVStore struct {
	ctrl     *gomock.Controller
	recorder *MockCommitKVStoreMockRecorder
}

// MockCommitKVStoreMockRecorder is the mock recorder for MockCommitKVStore
type MockCommitKVStoreMockRecorder struct {
	mock *MockCommitKVStore
}

// NewMockCommitKVStore creates a new mock instance
func NewMockCommitKVStore(ctrl *gomock.Controller) *MockCommitKVStore {
	mock := &MockCommitKVStore{ctrl: ctrl}
	mock.recorder = &MockCommitKVStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCommitKVStore) EXPECT() *MockCommitKVStoreMockRecorder {
	return m.recorder
}

// Commit mocks base method
func (m *MockCommitKVStore) Commit() types.CommitID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit")
	ret0, _ := ret[0].(types.CommitID)
	return ret0
}

// Commit indicates an expected call of Commit
func (mr *MockCommitKVStoreMockRecorder) Commit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MockCommitKVStore)(nil).Commit))
}

// LastCommitID mocks base method
func (m *MockCommitKVStore) LastCommitID() types.CommitID {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LastCommitID")
	ret0, _ := ret[0].(types.CommitID)
	return ret0
}

// LastCommitID indicates an expected call of LastCommitID
func (mr *MockCommitKVStoreMockRecorder) LastCommitID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastCommitID", reflect.TypeOf((*MockCommitKVStore)(nil).LastCommitID))
}

// SetPruning mocks base method
func (m *MockCommitKVStore) SetPruning(arg0 types.PruningOptions) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetPruning", arg0)
}

// SetPruning indicates an expected call of SetPruning
func (mr *MockCommitKVStoreMockRecorder) SetPruning(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetPruning", reflect.TypeOf((*MockCommitKVStore)(nil).SetPruning), arg0)
}

// GetStoreType mocks base method
func (m *MockCommitKVStore) GetStoreType() types.StoreType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetStoreType")
	ret0, _ := ret[0].(types.StoreType)
	return ret0
}

// GetStoreType indicates an expected call of GetStoreType
func (mr *MockCommitKVStoreMockRecorder) GetStoreType() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetStoreType", reflect.TypeOf((*MockCommitKVStore)(nil).GetStoreType))
}

// CacheWrap mocks base method
func (m *MockCommitKVStore) CacheWrap() types.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrap")
	ret0, _ := ret[0].(types.CacheWrap)
	return ret0
}

// CacheWrap indicates an expected call of CacheWrap
func (mr *MockCommitKVStoreMockRecorder) CacheWrap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrap", reflect.TypeOf((*MockCommitKVStore)(nil).CacheWrap))
}

// CacheWrapWithTrace mocks base method
func (m *MockCommitKVStore) CacheWrapWithTrace(w io.Writer, tc types.TraceContext) types.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrapWithTrace", w, tc)
	ret0, _ := ret[0].(types.CacheWrap)
	return ret0
}

// CacheWrapWithTrace indicates an expected call of CacheWrapWithTrace
func (mr *MockCommitKVStoreMockRecorder) CacheWrapWithTrace(w, tc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrapWithTrace", reflect.TypeOf((*MockCommitKVStore)(nil).CacheWrapWithTrace), w, tc)
}

// Get mocks base method
func (m *MockCommitKVStore) Get(key []byte) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", key)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// Get indicates an expected call of Get
func (mr *MockCommitKVStoreMockRecorder) Get(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCommitKVStore)(nil).Get), key)
}

// Has mocks base method
func (m *MockCommitKVStore) Has(key []byte) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Has", key)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Has indicates an expected call of Has
func (mr *MockCommitKVStoreMockRecorder) Has(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Has", reflect.TypeOf((*MockCommitKVStore)(nil).Has), key)
}

// Set mocks base method
func (m *MockCommitKVStore) Set(key, value []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Set", key, value)
}

// Set indicates an expected call of Set
func (mr *MockCommitKVStoreMockRecorder) Set(key, value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockCommitKVStore)(nil).Set), key, value)
}

// Delete mocks base method
func (m *MockCommitKVStore) Delete(key []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Delete", key)
}

// Delete indicates an expected call of Delete
func (mr *MockCommitKVStoreMockRecorder) Delete(key interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockCommitKVStore)(nil).Delete), key)
}

// Iterator mocks base method
func (m *MockCommitKVStore) Iterator(start, end []byte) types.Iterator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Iterator", start, end)
	ret0, _ := ret[0].(types.Iterator)
	return ret0
}

// Iterator indicates an expected call of Iterator
func (mr *MockCommitKVStoreMockRecorder) Iterator(start, end interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Iterator", reflect.TypeOf((*MockCommitKVStore)(nil).Iterator), start, end)
}

// ReverseIterator mocks base method
func (m *MockCommitKVStore) ReverseIterator(start, end []byte) types.Iterator {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReverseIterator", start, end)
	ret0, _ := ret[0].(types.Iterator)
	return ret0
}

// ReverseIterator indicates an expected call of ReverseIterator
func (mr *MockCommitKVStoreMockRecorder) ReverseIterator(start, end interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReverseIterator", reflect.TypeOf((*MockCommitKVStore)(nil).ReverseIterator), start, end)
}

// MockCacheWrap is a mock of CacheWrap interface
type MockCacheWrap struct {
	ctrl     *gomock.Controller
	recorder *MockCacheWrapMockRecorder
}

// MockCacheWrapMockRecorder is the mock recorder for MockCacheWrap
type MockCacheWrapMockRecorder struct {
	mock *MockCacheWrap
}

// NewMockCacheWrap creates a new mock instance
func NewMockCacheWrap(ctrl *gomock.Controller) *MockCacheWrap {
	mock := &MockCacheWrap{ctrl: ctrl}
	mock.recorder = &MockCacheWrapMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCacheWrap) EXPECT() *MockCacheWrapMockRecorder {
	return m.recorder
}

// Write mocks base method
func (m *MockCacheWrap) Write() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Write")
}

// Write indicates an expected call of Write
func (mr *MockCacheWrapMockRecorder) Write() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockCacheWrap)(nil).Write))
}

// CacheWrap mocks base method
func (m *MockCacheWrap) CacheWrap() types.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrap")
	ret0, _ := ret[0].(types.CacheWrap)
	return ret0
}

// CacheWrap indicates an expected call of CacheWrap
func (mr *MockCacheWrapMockRecorder) CacheWrap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrap", reflect.TypeOf((*MockCacheWrap)(nil).CacheWrap))
}

// CacheWrapWithTrace mocks base method
func (m *MockCacheWrap) CacheWrapWithTrace(w io.Writer, tc types.TraceContext) types.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrapWithTrace", w, tc)
	ret0, _ := ret[0].(types.CacheWrap)
	return ret0
}

// CacheWrapWithTrace indicates an expected call of CacheWrapWithTrace
func (mr *MockCacheWrapMockRecorder) CacheWrapWithTrace(w, tc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrapWithTrace", reflect.TypeOf((*MockCacheWrap)(nil).CacheWrapWithTrace), w, tc)
}

// MockCacheWrapper is a mock of CacheWrapper interface
type MockCacheWrapper struct {
	ctrl     *gomock.Controller
	recorder *MockCacheWrapperMockRecorder
}

// MockCacheWrapperMockRecorder is the mock recorder for MockCacheWrapper
type MockCacheWrapperMockRecorder struct {
	mock *MockCacheWrapper
}

// NewMockCacheWrapper creates a new mock instance
func NewMockCacheWrapper(ctrl *gomock.Controller) *MockCacheWrapper {
	mock := &MockCacheWrapper{ctrl: ctrl}
	mock.recorder = &MockCacheWrapperMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCacheWrapper) EXPECT() *MockCacheWrapperMockRecorder {
	return m.recorder
}

// CacheWrap mocks base method
func (m *MockCacheWrapper) CacheWrap() types.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrap")
	ret0, _ := ret[0].(types.CacheWrap)
	return ret0
}

// CacheWrap indicates an expected call of CacheWrap
func (mr *MockCacheWrapperMockRecorder) CacheWrap() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrap", reflect.TypeOf((*MockCacheWrapper)(nil).CacheWrap))
}

// CacheWrapWithTrace mocks base method
func (m *MockCacheWrapper) CacheWrapWithTrace(w io.Writer, tc types.TraceContext) types.CacheWrap {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CacheWrapWithTrace", w, tc)
	ret0, _ := ret[0].(types.CacheWrap)
	return ret0
}

// CacheWrapWithTrace indicates an expected call of CacheWrapWithTrace
func (mr *MockCacheWrapperMockRecorder) CacheWrapWithTrace(w, tc interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CacheWrapWithTrace", reflect.TypeOf((*MockCacheWrapper)(nil).CacheWrapWithTrace), w, tc)
}

// MockStoreKey is a mock of StoreKey interface
type MockStoreKey struct {
	ctrl     *gomock.Controller
	recorder *MockStoreKeyMockRecorder
}

// MockStoreKeyMockRecorder is the mock recorder for MockStoreKey
type MockStoreKeyMockRecorder struct {
	mock *MockStoreKey
}

// NewMockStoreKey creates a new mock instance
func NewMockStoreKey(ctrl *gomock.Controller) *MockStoreKey {
	mock := &MockStoreKey{ctrl: ctrl}
	mock.recorder = &MockStoreKeyMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockStoreKey) EXPECT() *MockStoreKeyMockRecorder {
	return m.recorder
}

// Name mocks base method
func (m *MockStoreKey) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name
func (mr *MockStoreKeyMockRecorder) Name() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockStoreKey)(nil).Name))
}

// String mocks base method
func (m *MockStoreKey) String() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "String")
	ret0, _ := ret[0].(string)
	return ret0
}

// String indicates an expected call of String
func (mr *MockStoreKeyMockRecorder) String() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "String", reflect.TypeOf((*MockStoreKey)(nil).String))
}
